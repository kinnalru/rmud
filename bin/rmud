#!/bin/env ruby

require 'optparse'
require 'securerandom'
require 'daemons'
require 'rmud'
require 'fcntl'

UTIL = File.basename(__FILE__)

STDOUT.sync = true rescue nil
STDERR.sync = true rescue nil

@opts = {
  id:     'main',
  client: 'mudlet',
  dir:    '.rmud'
}


parser = OptionParser.new do |o|
  o.banner = "Usage: #{UTIL} [options] start|stop|restart|run|status "

  o.separator ''
  o.separator 'Bot options:'

  o.on("--id=#{@opts[:id]}", 'set id') do |id|
    @opts[:id] = id.strip
  end

  o.on('--attach=OUT', 'set id') do |attach|
    @opts[:attach] = attach.strip
  end

  o.on('--tintin', 'generate tintin integrtion commands') do
    @opts[:client] = 'tintin'
  end

  o.on('--mudlet', 'run as mudlet bot') do
    @opts[:client] = 'mudlet'
  end
end
@args = parser.parse!

@opts[:dir] = File.expand_path(@opts[:dir])
FileUtils.mkdir_p(@opts[:dir]) unless File.exist?(@opts[:dir])

if out = @opts[:attach]
  exec 'tail', '-f', "#{@opts[:dir]}/#{out}.out"
end

Dir.chdir(@opts[:dir])

conn = nil
bot = nil

if @opts[:client] == 'mudlet'
  $real_stdin_close = STDIN.method(:close)
  $real_stdin_reopen = STDIN.method(:reopen)

  $stdin.instance_eval do
    define_singleton_method(:close) do |*_args|
      nil
    end

    define_singleton_method(:reopen) do |*_args|
      nil
    end
  end
end

Daemons.run_proc(@opts[:id], dir: @opts[:dir], dir_mode: :normal, log_output: true, ARGV: @args) do
  Dir.chdir(@opts[:dir])

  STDOUT.sync = true rescue nil
  STDERR.sync = true rescue nil

  if @opts[:client] == 'tintin'
    conn = RMud::FifoConnection.new(dir: @opts[:dir], id: @opts[:id])
    bot = RMud::Bot.new(conn, api_class: RMud::Api::TinTin)
  elsif @opts[:client] == 'mudlet'
    $stdin.instance_eval do
      define_singleton_method(:close, &$real_stdin_close)
      define_singleton_method(:reopen, &$real_stdin_reopen)
    end

    out_fd = STDOUT.fcntl(Fcntl::F_DUPFD)
    out = IO.new(out_fd, mode: 'w')
    out.sync = true

    $stdout.reopen("#{@opts[:dir]}/#{@opts[:id]}.output")
    $stderr.close rescue nil
    STDOUT = $stderr = STDERR = $stdout

    conn = RMud::StdConnection.new(instream: STDIN, outstream: out)
    bot = RMud::Bot.new(conn, api_class: RMud::Api::Mudlet)
  end

  Signal.trap 'TERM' do
    Thread.new do
      puts 'Terminating gracefully...'
      bot&.stop rescue nil
    end
  end

  Signal.trap 'INT' do
    Thread.new do
      puts 'Stopping gracefully...'
      bot&.stop rescue nil
    end
  end

  bot.start(block: true)
ensure
  if bot && !bot.stopped?
    puts 'EXITING....'
    bot.stop rescue nil
  end
  conn.stop if conn && !conn.stopped?
end

if @opts[:client] == 'tintin'
  script = "#{@opts[:dir]}/#{@opts[:id]}.tin"
  File.write(script, "
  #showme Initializing rmud bot connection at #{@opts[:dir]}..
  #split
  #action {%1} {#script { echo \"%1\" >> #{conn.infile} 2> /dev/null; cat #{conn.outfile} 2>/dev/null};}
  #ticker bot {#script { cat #{conn.outfile} 2>/dev/null };} {1}
  #script {rmud} {#{__FILE__} --id #{opts[:id]} status}
  #delay 0.1 #showme rmud bot $rmud[1]
  #session main mud.c7i.ru 9000
  #function {rmud}
  {
    #showme {rmud %0};
    #return 0;
  };
  ".lstrip)

  exec 'tt++', '-r', script.to_s
end

